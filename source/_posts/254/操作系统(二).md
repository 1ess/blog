---
title: 操作系统(二)
featured_image: https://cdn-fawn.vercel.app/blogImg/Blog254.jpg
date: 2023/04/06
---

## 进程 API
***  
UNIX 系统通过一对系统调用: fork()和 exec() 来创建进程。还可以通过 wait() 系统调用，来等  
待其创建的子进程执行完成。

### fork 系统调用
系统调用 fork() 用于创建新进程，不同于一般的函数，其返回两次。
``` c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
  printf("hello world (pid:%d)\n", (int) getpid());
  int rc = fork();
  if (rc < 0) { // fork failed; exit
    fprintf(stderr, "fork failed\n");
    exit(1);
  } else if (rc == 0) { // child (new process)
    printf("hello, I am child (pid:%d)\n", (int) getpid());
  } else { // parent goes down this path (main)
    printf("hello, I am parent of %d (pid:%d)\n", rc, (int) getpid());
  }
  return 0;
}

// 输出如下:
// hello world (pid:29146)
// hello, I am parent of 29147 (pid:29146)
// hello, I am child (pid:29147)
// 或者
// hello world (pid:29146)
// hello, I am child (pid:29147)
// hello, I am parent of 29147 (pid:29146)
```

父进程获得的返回值是新创建子进程的 PID，而子进程获得的返回值是 0。它的输出顺序是不确定的，子进程可能先运行也可能是父进程先运行。CPU 调度程序(**scheduler**)决定了某一时刻哪个进程被执行。

### wait 系统调用
``` c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[])
{
  printf("hello world (pid:%d)\n", (int) getpid());
  int rc = fork();
  if (rc < 0) { // fork failed; exit
    fprintf(stderr, "fork failed\n");
    exit(1);
  } else if (rc == 0) { // child (new process)
    printf("hello, I am child (pid:%d)\n", (int) getpid());
  } else { // parent goes down this path (main)
    int wc = wait(NULL);
    printf("hello, I am parent of %d (wc:%d) (pid:%d)\n", rc, wc, (int) getpid());
  }
  return 0;
}
// 输出如下: 
// hello world (pid:29266)
// hello, I am child (pid:29267)
// hello, I am parent of 29267 (wc:29267) (pid:29266)
```

父进程调用 wait() 系统调用，延迟自己的执行直到子进程执行完毕。当子进程结束时，wait() 函数才返回。
那么，上述例子的输出结果就是确定的。

### exec 系统调用
exec() 系统调用可以让子进程执行与父进程不同的程序。
``` c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>
int main(int argc, char *argv[])
{
  printf("hello world (pid:%d)\n", (int) getpid());
  int rc = fork();
  if (rc < 0) { // fork failed; exit
    fprintf(stderr, "fork failed\n");
    exit(1);
  } else if (rc == 0) { // child (new process)
    printf("hello, I am child (pid:%d)\n", (int) getpid());
    char *myargs[3];
    myargs[0] = strdup("wc"); // program: "wc" (word count)
    myargs[1] = strdup("p3.c"); // argument: file to count
    myargs[2] = NULL; // marks end of array
    execvp(myargs[0], myargs); // runs word count
    printf("this shouldn't print out");
  } else { // parent goes down this path (main)
    int wc = wait(NULL);
    printf("hello, I am parent of %d (wc:%d) (pid:%d)\n", rc, wc, (int) getpid());
  }
  return 0;
}

// 输出如下: 
// hello world (pid:29383)
// hello, I am child (pid:29384)
// 29 107 1030 p3.c
// hello, I am parent of 29384 (wc:29384) (pid:29383)
```

### 其他系统调用
除了 fork()、exec() 和 wait() 之外，UNIX 中还有其他许多系统调用比如可以通过 kill() 系统调用向进程发送信号(**signal**)。